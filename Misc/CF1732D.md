### CF1732D(1/2) （*$\color{cyan}{1500}$ / *$\color{red}{2400}$）

考虑到弱化版只有添加和查询没有删除，因此对于每一个相同的 $k$ 随时间推移答案肯定单调不降。所以直接用 `set` 维护当前所有出现过的数，然后用 `map` 暴力维护每一个 $k$ 当前的答案即可。更新的时候无需维护，只需要在查询的时候直接暴力往上跳答案即可。没有什么手法。

在弱化版没有删除操作，因此对于同一个 $k$ 的答案是单调的，可以直接暴力维护；但是在困难版本中，删除操作导致某一些 $k$ 的值可能会突然反弹回去。而如果暴力枚举所有因数然后把值清空，又有可能陷入删除 - 添加 - 删除 - 添加 - …… 的困境，导致时间复杂度很劣。

那么应该如何避免这种情况呢？简单粗暴的算法肯定不可行了，因此考虑一些奇奇怪怪的做法：设立一个阈值 $P$，对于加入操作还是直接加入一个 `set` 中，删除操作则记录当前所有被删除的元素。查询操作仍然是先暴力跳，然后枚举所有被删除的元素 check 是否用这个元素会合法且让当前答案更优。**为了保证时间复杂度，若某一次操作后删除元素集合的元素数量 $>P$，则直接暴力重构当前集合。**

继续用 `map/set` 系列平衡树相关 STL 时间复杂度多个 $\log$，因此考虑用 `umap/uset` 加 splitmix64 hash，时间复杂度为 $O(qP+\frac qPq\log q)$，根号平衡即 $qP=\frac qPq\log q$，解得 $P=\sqrt{q\log q}$ 时等号成立，此时根号平衡。因此总时间复杂度为 $O(q\sqrt{q\log q}+\frac{q^2\log q}{\sqrt{q\log q}})$，可以通过。